# 纹理（Textures）

我们正在逐渐从高层向低层递进。我们已经讨论了场景图，以及通常关于存在其中的显示对象的内容。我们即将开始讨论精灵和其他简单的显示对象。但在这之前，我们需要谈论一下纹理。

在 PixiJS 中，纹理是显示对象使用的核心资源之一。从宏观上讲，纹理代表了用于填充屏幕上区域的像素源。最简单的示例是精灵 - 一个完全由单个纹理填充的矩形。但情况可以变得更加复杂。

## 纹理的生命周期

让我们通过追踪图像数据在传送到屏幕的过程中所经过的路径，来了解纹理是如何真正工作的。

以下是我们将要遵循的流程：源图像 > 加载器 > BaseTexture > 纹理（Texture）

### 提供图像

首先，您有要显示的图像。第一步是将其在您的服务器上提供。这可能似乎很明显，但如果您从其他游戏开发系统转到 PixiJS，值得记住的是，由于所有内容都必须通过网络加载，因此要牢记这一点。如果您是在本地开发，请注意您**必须**使用 Web 服务器进行测试，否则由于浏览器处理本地文件安全性的方式，您的图像将无法加载。

### 加载图像

要使用图像，首先的步骤是将图像文件从 Web 服务器拉到用户的 Web 浏览器中。为此，我们可以使用 `PIXI.Texture.from()`，这在快速演示中有效，但在生产中，您将使用 Loader 类。加载器将使用 `<IMG>` 元素包装和管理告诉浏览器获取图像的过程，并在完成后通知您。这个过程是*异步*的 - 您请求加载，然后时间流逝，然后触发事件通知您加载完成。我们将在后面的指南中更深入地介绍加载器。

### BaseTextures 拥有数据

加载器完成其工作后，加载的 `<IMG>` 元素包含了所需的像素数据。但是为了使用它来渲染某些内容，PixiJS 必须将原始图像文件上传到 GPU。这使我们来到了纹理系统的真正工作马 - [BaseTexture](https://pixijs.download/release/docs/PIXI.BaseTexture.html) 类。每个 BaseTexture 管理一个单独的像素源 - 通常是图像，但也可以是画布（Canvas）或视频元素。BaseTextures 允许 PixiJS 将图像转换为像素并在渲染中使用这些像素。此外，它还包含控制如何渲染纹理数据的设置，例如包围模式（用于超出 0.0-1.0 范围的 UV 坐标）和缩放模式（用于缩放纹理时）。

BaseTextures 会自动缓存，这样对于相同的 URL 反复调用 `PIXI.Texture.from()` 将每次返回相同的 BaseTexture。销毁 BaseTexture 将释放与其关联的图像数据。

### 纹理是对 BaseTextures 的视图

因此，最后，我们终于到达了 PIXI.Texture 类本身！此时，您可能想知道 Texture 对象*有什么用*。毕竟，BaseTexture 管理像素和渲染设置。答案是，它没有做太多事情。纹理是对基础 BaseTexture 的轻量级视图。它们的主要属性是从 BaseTexture 中提取的源矩形。

如果 PixiJS 只绘制精灵，那将是相当冗余的。但考虑一下 [精灵表](./sprite-sheets)。精灵表是包含在其中排列的多个精灵图像的单个图像。在 [Spritesheet](https://pixijs.download/release/docs/PIXI.Spritesheet.html) 对象中，一组纹理引用了单个 BaseTexture，每个原始精灵表中的源图像对应一个纹理。通过共享单个 BaseTexture，浏览器仅下载一个文件，并且我们的批处理渲染器可以通过绘制精灵来快速绘制，因为它们都共享相同的基础像素数据。精灵表的纹理从每个精灵所需的像素矩形中提取。

<!--TODO: 显示精灵表基础纹理的图像，以及每个精灵的纹理-->

这就是为什么我们同时拥有纹理和 BaseTexture - 为了允许将精灵表、动画、按钮状态等加载为单个图像，同时只显示所需的主图像部分。

## 加载纹理

我们将在以后的指南中讨论资源加载，但是新用户在构建 PixiJS 项目时最常遇到的一个问题是如何最好地加载纹理。在我们的演示代码片段中使用 `PIXI.Texture.from()` 将起作用，但会导致纹理在对象已经在场景图中渲染时被加载，从而导致弹出。

相反，这里是一个快速的解决方案的备忘单：

1. 显示加载图像
2. 创建一个加载器
3. 运行所有基于纹理的对象，将它们的纹理添加到加载器
4. 启动加载器，并根据进度回调可选择更新您的加载图像
5. 在加载器完成后

，运行所有对象，并使用 `PIXI.Texture.from()` 从纹理缓存中提取已加载的纹理
6. 准备您的纹理（可选 - 详见下文）
7. 隐藏您的加载图像，开始渲染您的场景图

使用此工作流程可确保预加载纹理，以防止弹出，并且相对较容易编码。

关于准备纹理：即使在加载了纹理后，图像仍然需要被推送到 GPU 并进行解码。对大量原始图像执行此操作可能会很慢，并在项目首次加载时导致延迟峰值。为解决这个问题，您可以使用 [Prepare](https://pixijs.download/release/docs/PIXI.Prepare.html) 插件，在显示项目之前的最后一步中预加载纹理。

## 卸载纹理

完成纹理后，您可能希望释放它使用的内存（包括 WebGL 管理的缓冲区和基于浏览器的内存）。为此，您应该在拥有数据的 BaseTexture 上调用 `destroy()`。请记住，纹理不管理像素数据！

这对于短暂的图像，例如仅使用一次且很大的过场动画来说是一个特别好的想法。如果您想要删除*所有*纹理并彻底清除，可以使用 `PIXI.utils.destroyTextureCache()` 函数。

## 超越图像

正如上面所提到的，您可以将纹理制作为不仅仅是图像：

视频：将 HTML5 `<VIDEO>` 元素传递给 `PIXI.BaseTexture.from()`，以便在项目中显示视频。因为它是一种纹理，所以您可以对其进行着色，添加滤镜，甚至将其应用于自定义几何体。

画布（Canvas）：类似地，您可以将 HTML5 `<CANVAS>` 元素包装在 BaseTexture 中，以便您可以使用画布的绘图方法来动态创建纹理。

SVG：传递一个 `<SVG>` 元素或加载 .svg URL，并且 PixiJS 将尝试对其进行光栅化。对于网络受限的项目，这可以在网络负载时间较短的情况下创建出色的图形。

渲染纹理：更高级（但非常强大！）的功能是通过 [RenderTexture](https://pixijs.download/release/docs/PIXI.RenderTexture.html) 从几何体构建纹理。这可以允许使用 [Geometry](https://pixijs.download/release/docs/PIXI.Geometry.html) 对象构建复杂的几何体，然后将该几何体烘焙成简单的纹理。

这些纹理来源都有无法在本指南中覆盖的注意事项和细微差别，但它们应该为您展示了 PixiJS 纹理系统的强大之处。<!--TODO: 高级纹理指南链接-->

查看 [渲染纹理示例代码](/examples/textures/render-texture-basic)。
