# 性能优化提示

### 总体

- 只在需要时进行优化！PixiJS 一开始就能处理相当多的内容
- 注意场景的复杂性。您添加的对象越多，速度就会变慢
- 排序可能有帮助，例如精灵 / 图形 / 精灵 / 图形 比精灵 / 精灵 / 图形 / 图形 更慢
- 一些较旧的移动设备运行速度稍慢。将选项 `useContextAlpha: false` 和 `antialias: false` 传递给渲染器或应用程序可以提高性能
- 默认情况下，裁剪被禁用，因为在应用程序级别进行此操作通常更好，或者将对象设置为 `cullable = true`。如果您的 GPU 负载较重，它会提高性能；如果您的 CPU 负载较重，它会降低性能

### 精灵（Sprites）

- 尽可能使用精灵表（Spritesheets）以最小化总纹理数
- 精灵可以与多达 16 种不同的纹理一起批处理（取决于硬件）
- 这是渲染内容的最快方法
- 在较旧的设备上使用较小的低分辨率纹理
- 将 50％ 缩放的精灵表添加扩展名 `@0.5x.png`，这样 PixiJS 将自动将其视觉上放大两倍
- 绘制顺序可能很重要

### 图形（Graphics）

- 图形在不经常修改时速度最快（不包括变换、透明度或着色！）
- 图形对象在某个大小范围内（100 个点或更小）时进行批处理
- 小的图形对象与精灵一样快速（矩形、三角形）
- 使用数百个复杂的图形对象可能会很慢，在这种情况下使用精灵（您可以创建一个纹理）

### 纹理（Texture）

- 纹理由纹理垃圾收集器自动管理
- 您还可以通过使用 `texture.destroy()` 自行管理纹理
- 如果您计划一次销毁多个纹理，请在销毁它们之前添加随机延迟，以避免冻结
- 如果您计划自己删除大量纹理，则延迟纹理销毁

### 文本（Text）

- 避免在每帧上都进行更改，因为这可能会很昂贵（每次它绘制到画布然后上传到 GPU）
- 对于动态更改的文本，位图文本（Bitmap Text）的性能要好得多
- 文本分辨率与渲染器分辨率相匹配，通过设置 `resolution` 属性来自行减少分辨率，可以减少内存消耗

### 蒙版（Masks）

- 如果使用太多蒙版，可能会很昂贵：例如，使用了数百个蒙版会使事情变得非常慢
- 轴对齐的矩形蒙版是最快的（因为它们使用裁剪矩形）
- 图形蒙版是第二快的（因为它们使用模板缓冲区）
- 精灵蒙版是第三快的（它们使用滤镜）。它们的性能非常昂贵。在您的场景中不要使用太多！

### 滤镜（Filters）

- 释放内存：`displayObject.filters = null`
- 如果您知道它们的大小：`displayObject.filterArea = new PIXI.Rectangle(x,y,w,h)`。这可以加快速度，因为这意味着不需要测量对象
- 滤镜的性能开销很大，使用太多会开始变慢！

### 混合模式（BlendModes）

- 不同的混合模式会导致批次中断（变得非优化）
- SceenSprite / NormalSprite / SceenSprite / NormalSprite 将有 4 个绘制调用
- SceenSprite / SceenSprite / NormalSprite / NormalSprite 将有 2 个绘制调用

### CacheAsBitmap

- 将其设置为 `true` 会将对象作为纹理缓存为精灵
- 当激活时，它会有一次性成本，因为它将对象绘制到纹理中
- 避免频繁更改此元素上的设置
- 如果您有一个复杂的项目，其中有许多精灵/滤镜并且不移动，那么这将加速渲染！
- 不需要应用于精灵，因为它们已经是纹理
- 如果其子项经常变化，不要使用，因为这会使性能变慢

### 事件

- 如果对象没有交互性子项，请使用 `interactiveChildren = false`。事件系统将能够避免遍历对象
- 将 `hitArea = new PIXI.Rectangle(x,y,w,h)` 设置为上述内容应该可以阻止事件系统遍历对象
